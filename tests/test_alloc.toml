# Tests covering properties of the block allocator

# The ordering of these tests vs higher-level tests (files/dirs/etc) gets
# a bit weird because there is an inherent cyclic dependency
#
# It's counter-intuitive, but we run the alloc tests _after_ file/dir tests,
# since you can usually ignore allocator issues temporarily by making the test
# device really big
#
after = ['test_mtree', 'test_dirs', 'test_files']

# test that we can alloc
[cases.test_alloc_alloc]
defines.COUNT = [
    'BLOCK_COUNT',
    'BLOCK_COUNT-1',
    'BLOCK_COUNT/2',
    'BLOCK_COUNT/4',
    '5',
    '2',
]
defines.ERASE = [false, true]
in = 'lfs.c'
code = '''
    // test various block counts
    struct lfs_config cfg = *CFG;
    cfg.block_count = COUNT;
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, &cfg) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;

    // start allocating
    lfs_alloc_ckpoint(&lfs);
    lfs_size_t alloced = 0;
    while (true) {
        lfs_sblock_t block = lfs_alloc(&lfs, ERASE);
        assert(block >= 0 || block == LFS_ERR_NOSPC);

        if (block == LFS_ERR_NOSPC) {
            break;
        }
        alloced += 1;

        // our allocator should stop at some point...
        assert(alloced < 2*COUNT);
    }

    // excluding our mroot, we should have allocated exactly
    // block_count-2 blocks
    printf("alloced %d/%d blocks\n", alloced, (lfs_block_t)COUNT);
    assert(alloced == COUNT-2);

    lfsr_unmount(&lfs) => 0;
'''

# test that we can realloc after an ack
[cases.test_alloc_reuse]
defines.COUNT = [
    'BLOCK_COUNT',
    'BLOCK_COUNT-1',
    'BLOCK_COUNT/2',
    'BLOCK_COUNT/4',
    '5',
    '2',
]
defines.ERASE = [false, true]
in = 'lfs.c'
code = '''
    // test various block counts
    struct lfs_config cfg = *CFG;
    cfg.block_count = COUNT;
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, &cfg) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;

    // start allocating
    lfs_alloc_ckpoint(&lfs);
    lfs_size_t alloced = 0;
    while (true) {
        lfs_sblock_t block = lfs_alloc(&lfs, ERASE);
        assert(block >= 0 || block == LFS_ERR_NOSPC);

        if (block == LFS_ERR_NOSPC) {
            break;
        }
        alloced += 1;

        // our allocator should stop at some point...
        assert(alloced < 2*COUNT);
    }

    // excluding our mroot, we should have allocated exactly
    // block_count-2 blocks
    printf("alloced %d/%d blocks\n", alloced, (lfs_block_t)COUNT);
    assert(alloced == COUNT-2);

    // ack again, effectively releasing all the previously alloced blocks
    lfs_alloc_ckpoint(&lfs);
    alloced = 0;
    while (true) {
        lfs_sblock_t block = lfs_alloc(&lfs, ERASE);
        assert(block >= 0 || block == LFS_ERR_NOSPC);

        if (block == LFS_ERR_NOSPC) {
            break;
        }
        alloced += 1;

        // our allocator should stop at some point...
        assert(alloced < 2*COUNT);
    }

    // excluding our mroot, we should have allocated exactly
    // block_count-2 blocks
    printf("alloced %d/%d blocks\n", alloced, (lfs_block_t)COUNT);
    assert(alloced == COUNT-2);

    lfsr_unmount(&lfs) => 0;
'''


# clobber tests test that our traversal algorithm works
[cases.test_alloc_clobber_dirs]
defines.N = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
defines.CKMETA = [false, true]
defines.REMOUNT = [false, true]
in = 'lfs.c'
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, CFG) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;

    // create this many directories
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%03x", i);
        lfsr_mkdir(&lfs, name) => 0;
    }

    // check that our mkdir worked
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%03x", i);
        struct lfs_info info;
        lfsr_stat(&lfs, name, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
    }

    lfsr_dir_t dir;
    lfsr_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, ".") == 0);
    assert(info.type == LFS_TYPE_DIR);
    assert(info.size == 0);
    lfsr_dir_read(&lfs, &dir, &info) => 0;
    assert(strcmp(info.name, "..") == 0);
    assert(info.type == LFS_TYPE_DIR);
    assert(info.size == 0);
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "dir%03x", i);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
    }
    lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
    lfsr_dir_close(&lfs, &dir) => 0;

    // remount?
    if (REMOUNT) {
        lfsr_unmount(&lfs) => 0;
        lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;
    }

    // first traverse the tree to find all blocks in use
    uint8_t *seen = malloc((BLOCK_COUNT+7)/8);
    memset(seen, 0, (BLOCK_COUNT+7)/8);

    lfsr_traversal_t t;
    lfsr_traversal_init(&t,
            LFS_T_RDONLY
                | ((CKMETA) ? LFS_T_CKMETA : 0));
    for (lfs_block_t i = 0;; i++) {
        // a bit hacky, but this catches infinite loops
        assert(i < 2*BLOCK_COUNT);

        lfsr_tag_t tag;
        lfsr_bptr_t bptr;
        int err = lfsr_mtree_traverse(&lfs, &t,
                &tag, &bptr);
        assert(!err || err == LFS_ERR_NOENT);
        if (err == LFS_ERR_NOENT) {
            break;
        }

        if (tag == LFSR_TAG_MDIR) {
            lfsr_mdir_t *mdir = (lfsr_mdir_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x mdir 0x{%x,%x}\n",
                    tag,
                    mdir->rbyd.blocks[0],
                    mdir->rbyd.blocks[1]);

            // keep track of seen blocks
            seen[mdir->rbyd.blocks[1] / 8] |= 1 << (mdir->rbyd.blocks[1] % 8);
            seen[mdir->rbyd.blocks[0] / 8] |= 1 << (mdir->rbyd.blocks[0] % 8);

        } else if (tag == LFSR_TAG_BRANCH) {
            lfsr_rbyd_t *rbyd = (lfsr_rbyd_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x btree 0x%x.%x\n",
                    tag,
                    rbyd->blocks[0], rbyd->trunk);

            // keep track of seen blocks
            seen[rbyd->blocks[0] / 8] |= 1 << (rbyd->blocks[0] % 8);

        } else {
            // this shouldn't happen
            printf("traversal: 0x%x\n", tag);
            assert(false);
        }
    }

    // then clobber every other block
    uint8_t clobber_buf[BLOCK_SIZE];
    memset(clobber_buf, 0xcc, BLOCK_SIZE);
    for (lfs_block_t block = 0; block < BLOCK_COUNT; block++) {
        if (!(seen[block / 8] & (1 << (block % 8)))) {
            CFG->erase(CFG, block) => 0;
            CFG->prog(CFG, block, 0, clobber_buf, BLOCK_SIZE) => 0;
        }
    }
    free(seen);

    // then check that we can read our directories after clobbering
    for (int remount = 0; remount < 2; remount++) {
        // remount?
        if (remount) {
            lfsr_unmount(&lfs) => 0;
            lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;
        }

        for (lfs_size_t i = 0; i < N; i++) {
            char name[256];
            sprintf(name, "dir%03x", i);
            struct lfs_info info;
            lfsr_stat(&lfs, name, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
            assert(info.size == 0);
        }

        lfsr_dir_open(&lfs, &dir, "/") => 0;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
        for (lfs_size_t i = 0; i < N; i++) {
            char name[256];
            sprintf(name, "dir%03x", i);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
            assert(info.size == 0);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
        lfsr_dir_close(&lfs, &dir) => 0;
    }

    lfsr_unmount(&lfs) => 0;
'''

[cases.test_alloc_clobber_files]
defines.N = [1, 2, 4, 8, 16, 32, 64]
defines.SIZE = [
    '0',
    'FILE_CACHE_SIZE/2',
    '2*FILE_CACHE_SIZE',
    'BLOCK_SIZE/2',
    'BLOCK_SIZE',
    '2*BLOCK_SIZE',
    '8*BLOCK_SIZE',
]
defines.CKMETA = [false, true]
defines.REMOUNT = [false, true]
in = 'lfs.c'
if = '(SIZE*N)/BLOCK_SIZE <= 32'
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, CFG) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;

    // create this many files
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "file%03x", i);

        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        lfsr_file_t file;
        lfsr_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfsr_file_write(&lfs, &file, wbuf, SIZE) => SIZE;
        lfsr_file_close(&lfs, &file) => 0;
    }

    // check that our writes worked
    prng = 42;
    for (lfs_size_t i = 0; i < N; i++) {
        // check with stat
        char name[256];
        sprintf(name, "file%03x", i);
        struct lfs_info info;
        lfsr_stat(&lfs, name, &info) => 0;
        assert(strcmp(info.name, name) == 0);
        assert(info.type == LFS_TYPE_REG);
        assert(info.size == SIZE);

        // try reading the file, note we reset prng above
        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        lfsr_file_t file;
        uint8_t rbuf[SIZE];
        lfsr_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
        lfsr_file_read(&lfs, &file, rbuf, SIZE) => SIZE;
        assert(memcmp(rbuf, wbuf, SIZE) == 0);
        lfsr_file_close(&lfs, &file) => 0;
    }

    // remount?
    if (REMOUNT) {
        lfsr_unmount(&lfs) => 0;
        lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;
    }

    // first traverse the tree to find all blocks in use
    uint8_t *seen = malloc((BLOCK_COUNT+7)/8);
    memset(seen, 0, (BLOCK_COUNT+7)/8);

    lfsr_traversal_t t;
    lfsr_traversal_init(&t,
            LFS_T_RDONLY
                | ((CKMETA) ? LFS_T_CKMETA : 0));
    for (lfs_block_t i = 0;; i++) {
        // a bit hacky, but this catches infinite loops
        assert(i < 2*BLOCK_COUNT);

        lfsr_tag_t tag;
        lfsr_bptr_t bptr;
        int err = lfsr_mtree_traverse(&lfs, &t,
                &tag, &bptr);
        assert(!err || err == LFS_ERR_NOENT);
        if (err == LFS_ERR_NOENT) {
            break;
        }

        if (tag == LFSR_TAG_MDIR) {
            lfsr_mdir_t *mdir = (lfsr_mdir_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x mdir 0x{%x,%x}\n",
                    tag,
                    mdir->rbyd.blocks[0],
                    mdir->rbyd.blocks[1]);

            // keep track of seen blocks
            seen[mdir->rbyd.blocks[1] / 8] |= 1 << (mdir->rbyd.blocks[1] % 8);
            seen[mdir->rbyd.blocks[0] / 8] |= 1 << (mdir->rbyd.blocks[0] % 8);

        } else if (tag == LFSR_TAG_BRANCH) {
            lfsr_rbyd_t *rbyd = (lfsr_rbyd_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x btree 0x%x.%x\n",
                    tag,
                    rbyd->blocks[0], rbyd->trunk);

            // keep track of seen blocks
            seen[rbyd->blocks[0] / 8] |= 1 << (rbyd->blocks[0] % 8);

        } else if (tag == LFSR_TAG_BLOCK) {
            printf("traversal: 0x%x block 0x%x\n",
                    tag,
                    bptr.data.u.disk.block);

            // keep track of seen blocks
            seen[bptr.data.u.disk.block / 8]
                    |= 1 << (bptr.data.u.disk.block % 8);

        } else {
            // this shouldn't happen
            printf("traversal: 0x%x\n", tag);
            assert(false);
        }
    }

    // then clobber every other block
    uint8_t clobber_buf[BLOCK_SIZE];
    memset(clobber_buf, 0xcc, BLOCK_SIZE);
    for (lfs_block_t block = 0; block < BLOCK_COUNT; block++) {
        if (!(seen[block / 8] & (1 << (block % 8)))) {
            CFG->erase(CFG, block) => 0;
            CFG->prog(CFG, block, 0, clobber_buf, BLOCK_SIZE) => 0;
        }
    }
    free(seen);

    // then check that reading our files still works after clobbering
    for (int remount = 0; remount < 2; remount++) {
        // remount?
        if (remount) {
            lfsr_unmount(&lfs) => 0;
            lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;
        }

        prng = 42;
        for (lfs_size_t i = 0; i < N; i++) {
            // check with stat
            char name[256];
            sprintf(name, "file%03x", i);
            struct lfs_info info;
            lfsr_stat(&lfs, name, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_REG);
            assert(info.size == SIZE);

            // try reading the file, note we reset prng above
            uint8_t wbuf[SIZE];
            for (lfs_size_t j = 0; j < SIZE; j++) {
                wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
            }

            lfsr_file_t file;
            uint8_t rbuf[SIZE];
            lfsr_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
            lfsr_file_read(&lfs, &file, rbuf, SIZE) => SIZE;
            assert(memcmp(rbuf, wbuf, SIZE) == 0);
            lfsr_file_close(&lfs, &file) => 0;
        }
    }

    lfsr_unmount(&lfs) => 0;
'''

# open files need to be tracked internally to make sure this doesn't break
[cases.test_alloc_clobber_open_files]
defines.N = [1, 2, 4, 8, 16, 32, 64]
defines.SIZE = [
    '0',
    'FILE_CACHE_SIZE/2',
    '2*FILE_CACHE_SIZE',
    'BLOCK_SIZE/2',
    'BLOCK_SIZE',
    '2*BLOCK_SIZE',
    '8*BLOCK_SIZE',
]
defines.CKMETA = [false, true]
in = 'lfs.c'
if = '(SIZE*N)/BLOCK_SIZE <= 32'
code = '''
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, CFG) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;

    // create this many files
    lfsr_file_t files[N];
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < N; i++) {
        char name[256];
        sprintf(name, "file%03x", i);

        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        lfsr_file_open(&lfs, &files[i], name,
                LFS_O_RDWR | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfsr_file_write(&lfs, &files[i], wbuf, SIZE) => SIZE;
    }

    // check that our writes worked
    prng = 42;
    for (lfs_size_t i = 0; i < N; i++) {
        // try reading the file, note we reset prng above
        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        uint8_t rbuf[SIZE];
        lfsr_file_rewind(&lfs, &files[i]) => 0;
        lfsr_file_read(&lfs, &files[i], rbuf, SIZE) => SIZE;
        assert(memcmp(rbuf, wbuf, SIZE) == 0);
    }

    // first traverse the tree to find all blocks in use
    uint8_t *seen = malloc((BLOCK_COUNT+7)/8);
    memset(seen, 0, (BLOCK_COUNT+7)/8);

    lfsr_traversal_t t;
    lfsr_traversal_init(&t,
            LFS_T_RDONLY
                | ((CKMETA) ? LFS_T_CKMETA : 0));
    for (lfs_block_t i = 0;; i++) {
        // a bit hacky, but this catches infinite loops
        assert(i < 2*BLOCK_COUNT);

        lfsr_tag_t tag;
        lfsr_bptr_t bptr;
        int err = lfsr_mtree_traverse(&lfs, &t,
                &tag, &bptr);
        assert(!err || err == LFS_ERR_NOENT);
        if (err == LFS_ERR_NOENT) {
            break;
        }

        if (tag == LFSR_TAG_MDIR) {
            lfsr_mdir_t *mdir = (lfsr_mdir_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x mdir 0x{%x,%x}\n",
                    tag,
                    mdir->rbyd.blocks[0],
                    mdir->rbyd.blocks[1]);

            // keep track of seen blocks
            seen[mdir->rbyd.blocks[1] / 8]
                    |= 1 << (mdir->rbyd.blocks[1] % 8);
            seen[mdir->rbyd.blocks[0] / 8]
                    |= 1 << (mdir->rbyd.blocks[0] % 8);

        } else if (tag == LFSR_TAG_BRANCH) {
            lfsr_rbyd_t *rbyd = (lfsr_rbyd_t*)bptr.data.u.buffer;
            printf("traversal: 0x%x btree 0x%x.%x\n",
                    tag,
                    rbyd->blocks[0], rbyd->trunk);

            // keep track of seen blocks
            seen[rbyd->blocks[0] / 8]
                    |= 1 << (rbyd->blocks[0] % 8);

        } else if (tag == LFSR_TAG_BLOCK) {
            printf("traversal: 0x%x block 0x%x\n",
                    tag,
                    bptr.data.u.disk.block);

            // keep track of seen blocks
            seen[bptr.data.u.disk.block / 8]
                    |= 1 << (bptr.data.u.disk.block % 8);

        } else {
            // this shouldn't happen
            printf("traversal: 0x%x\n", tag);
            assert(false);
        }
    }

    // then clobber every other block
    uint8_t clobber_buf[BLOCK_SIZE];
    memset(clobber_buf, 0xcc, BLOCK_SIZE);
    for (lfs_block_t block = 0; block < BLOCK_COUNT; block++) {
        if (!(seen[block / 8] & (1 << (block % 8)))) {
            CFG->erase(CFG, block) => 0;
            CFG->prog(CFG, block, 0, clobber_buf, BLOCK_SIZE) => 0;
        }
    }
    free(seen);

    // then check that reading our files still works after clobbering
    prng = 42;
    for (lfs_size_t i = 0; i < N; i++) {
        // try reading the file, note we reset prng above
        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        uint8_t rbuf[SIZE];
        lfsr_file_rewind(&lfs, &files[i]) => 0;
        lfsr_file_read(&lfs, &files[i], rbuf, SIZE) => SIZE;
        assert(memcmp(rbuf, wbuf, SIZE) == 0);
    }

    // and everything is fine after saving the files
    for (lfs_size_t i = 0; i < N; i++) {
        lfsr_file_close(&lfs, &files[i]) => 0;
    }

    for (int remount = 0; remount < 2; remount++) {
        // remount?
        if (remount) {
            lfsr_unmount(&lfs) => 0;
            lfsr_mount(&lfs, LFS_M_RDWR, CFG) => 0;
        }

        prng = 42;
        for (lfs_size_t i = 0; i < N; i++) {
            // check with stat
            char name[256];
            sprintf(name, "file%03x", i);
            struct lfs_info info;
            lfsr_stat(&lfs, name, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_REG);
            assert(info.size == SIZE);

            // try reading the file, note we reset prng above
            uint8_t wbuf[SIZE];
            for (lfs_size_t j = 0; j < SIZE; j++) {
                wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
            }

            lfsr_file_t file;
            uint8_t rbuf[SIZE];
            lfsr_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
            lfsr_file_read(&lfs, &file, rbuf, SIZE) => SIZE;
            assert(memcmp(rbuf, wbuf, SIZE) == 0);
            lfsr_file_close(&lfs, &file) => 0;
        }
    }

    lfsr_unmount(&lfs) => 0;
'''


# TODO more nospc tests (opened files? other?)

# nospc tests mostly test that things still work when block allocation
# wraparound occurs
[cases.test_alloc_nospc_dirs]
defines.COUNT = [
    'BLOCK_COUNT',
    'BLOCK_COUNT-1',
    'BLOCK_COUNT/2',
    'BLOCK_COUNT/4',
    '5',
    '2',
]
code = '''
    // test various block counts
    struct lfs_config cfg = *CFG;
    cfg.block_count = COUNT;
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, &cfg) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;

    // create directories until we run out of space
    lfs_size_t n = 0;
    for (;; n++) {
        char name[256];
        sprintf(name, "dir%08d", n);
        int err = lfsr_mkdir(&lfs, name);
        assert(!err || err == LFS_ERR_NOSPC);
        if (err == LFS_ERR_NOSPC) {
            break;
        }
    }

    for (int remount = 0; remount < 2; remount++) {
        // remount?
        if (remount) {
            lfsr_unmount(&lfs) => 0;
            lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;
        }

        // check that our mkdir worked until we ran out of space
        for (lfs_size_t i = 0; i < n; i++) {
            char name[256];
            sprintf(name, "dir%08d", i);
            struct lfs_info info;
            lfsr_stat(&lfs, name, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
            assert(info.size == 0);
        }

        lfsr_dir_t dir;
        lfsr_dir_open(&lfs, &dir, "/") => 0;
        struct lfs_info info;
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, ".") == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
        lfsr_dir_read(&lfs, &dir, &info) => 0;
        assert(strcmp(info.name, "..") == 0);
        assert(info.type == LFS_TYPE_DIR);
        assert(info.size == 0);
        for (lfs_size_t i = 0; i < n; i++) {
            char name[256];
            sprintf(name, "dir%08d", i);
            lfsr_dir_read(&lfs, &dir, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_DIR);
            assert(info.size == 0);
        }
        lfsr_dir_read(&lfs, &dir, &info) => LFS_ERR_NOENT;
        lfsr_dir_close(&lfs, &dir) => 0;
    }

    lfsr_unmount(&lfs) => 0;
'''

[cases.test_alloc_nospc_files]
defines.COUNT = [
    'BLOCK_COUNT',
    'BLOCK_COUNT-1',
    'BLOCK_COUNT/2',
    'BLOCK_COUNT/4',
    '5',
    '2',
]
defines.SIZE = [
    '0',
    'FILE_CACHE_SIZE/2',
    '2*FILE_CACHE_SIZE',
    'BLOCK_SIZE/2',
    'BLOCK_SIZE',
    '2*BLOCK_SIZE',
    '8*BLOCK_SIZE',
]
code = '''
    // test various block counts
    struct lfs_config cfg = *CFG;
    cfg.block_count = COUNT;
    lfs_t lfs;
    lfsr_format(&lfs, LFS_F_RDWR, &cfg) => 0;
    lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;

    // create files until we run out of space
    uint32_t prng = 42;
    lfs_size_t n = 0;
    for (;; n++) {
        char name[256];
        sprintf(name, "file%08d", n);

        uint8_t wbuf[SIZE];
        for (lfs_size_t j = 0; j < SIZE; j++) {
            wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
        }

        lfsr_file_t file;
        int err = lfsr_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL);
        assert(!err || err == LFS_ERR_NOSPC);
        if (err == LFS_ERR_NOSPC) {
            break;
        }

        lfs_ssize_t size = lfsr_file_write(&lfs, &file, wbuf, SIZE);
        assert(size == SIZE || size == LFS_ERR_NOSPC);
        if (size == LFS_ERR_NOSPC) {
            lfsr_file_close(&lfs, &file) => 0;
            break;
        }

        err = lfsr_file_close(&lfs, &file);
        assert(!err || err == LFS_ERR_NOSPC);
        if (err == LFS_ERR_NOSPC) {
            break;
        }
    }

    for (int remount = 0; remount < 2; remount++) {
        // remount?
        if (remount) {
            lfsr_unmount(&lfs) => 0;
            lfsr_mount(&lfs, LFS_M_RDWR, &cfg) => 0;
        }

        // check that our file writes worked until we ran out of space
        prng = 42;
        for (lfs_size_t i = 0; i < n; i++) {
            // check with stat
            char name[256];
            sprintf(name, "file%08d", i);
            struct lfs_info info;
            lfsr_stat(&lfs, name, &info) => 0;
            assert(strcmp(info.name, name) == 0);
            assert(info.type == LFS_TYPE_REG);
            assert(info.size == SIZE);

            // try reading the file, note we reset prng above
            uint8_t wbuf[SIZE];
            for (lfs_size_t j = 0; j < SIZE; j++) {
                wbuf[j] = 'a' + (TEST_PRNG(&prng) % 26);
            }

            lfsr_file_t file;
            uint8_t rbuf[SIZE];
            lfsr_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
            lfsr_file_read(&lfs, &file, rbuf, SIZE) => SIZE;
            assert(memcmp(rbuf, wbuf, SIZE) == 0);
            lfsr_file_close(&lfs, &file) => 0;
        }
    }

    lfsr_unmount(&lfs) => 0;
'''

