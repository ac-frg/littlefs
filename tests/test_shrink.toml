# simple shrink
[cases.test_shrink_simple]
defines.BLOCK_COUNT = [10, 15, 20]
defines.AFTER_BLOCK_COUNT = [5, 10, 15, 19]
   
if = "AFTER_BLOCK_COUNT <= BLOCK_COUNT"
code = '''
#ifdef LFS2_SHRINKNONRELOCATING
    lfs2_t lfs2;
    lfs2_format(&lfs2, cfg) => 0;
    lfs2_mount(&lfs2, cfg) => 0;
    lfs2_fs_grow(&lfs2, AFTER_BLOCK_COUNT) => 0;
    lfs2_unmount(&lfs2);
    if (BLOCK_COUNT != AFTER_BLOCK_COUNT) {
        lfs2_mount(&lfs2, cfg) => LFS2_ERR_INVAL;
    }
    lfs2_t lfs22 = lfs2;
    struct lfs2_config cfg2 = *cfg;
    cfg2.block_count = AFTER_BLOCK_COUNT;
    lfs22.cfg = &cfg2;
    lfs2_mount(&lfs22, &cfg2) => 0;
    lfs2_unmount(&lfs22) => 0;
#endif
'''

# shrinking full
[cases.test_shrink_full]
defines.BLOCK_COUNT = [10, 15, 20]
defines.AFTER_BLOCK_COUNT = [5, 7, 10, 12, 15, 17, 20]
defines.FILES_COUNT = [7, 8, 9, 10]
if = "AFTER_BLOCK_COUNT <= BLOCK_COUNT && FILES_COUNT + 2 < BLOCK_COUNT"
code = '''
#ifdef LFS2_SHRINKNONRELOCATING
    lfs2_t lfs2;
    lfs2_format(&lfs2, cfg) => 0;
    // create FILES_COUNT files of BLOCK_SIZE - 50 bytes (to avoid inlining)
    lfs2_mount(&lfs2, cfg) => 0;
    for (int i = 0; i < FILES_COUNT + 1; i++) {
        lfs2_file_t file;
        char path[1024];
        sprintf(path, "file_%03d", i);
        lfs2_file_open(&lfs2, &file, path,
                LFS2_O_WRONLY | LFS2_O_CREAT | LFS2_O_EXCL) => 0;
        char wbuffer[BLOCK_SIZE];
        memset(wbuffer, 'b', BLOCK_SIZE);
        // Ensure one block is taken per file, but that files are not inlined.
        lfs2_size_t size = BLOCK_SIZE - 0x40;
        sprintf(wbuffer, "Hi %03d", i);
        lfs2_file_write(&lfs2, &file, wbuffer, size) => size;
        lfs2_file_close(&lfs2, &file) => 0;
    }

    int err = lfs2_fs_grow(&lfs2, AFTER_BLOCK_COUNT);
    if (err == 0) {
        for (int i = 0; i < FILES_COUNT + 1; i++) {
            lfs2_file_t file;
            char path[1024];
            sprintf(path, "file_%03d", i);
            lfs2_file_open(&lfs2, &file, path,
                    LFS2_O_RDONLY ) => 0;
            lfs2_size_t size = BLOCK_SIZE - 0x40;
            char wbuffer[size];
            char wbuffer_ref[size];
            // Ensure one block is taken per file, but that files are not inlined.
            memset(wbuffer_ref, 'b', size);
            sprintf(wbuffer_ref, "Hi %03d", i);
            lfs2_file_read(&lfs2, &file, wbuffer, BLOCK_SIZE) => size;
            lfs2_file_close(&lfs2, &file) => 0;
            for (lfs2_size_t j = 0; j < size; j++) {
                wbuffer[j] => wbuffer_ref[j];
            }
        }
    } else {
        assert(err == LFS2_ERR_NOTEMPTY);
    }

    lfs2_unmount(&lfs2) => 0;
    if (err == 0 ) {
        if ( AFTER_BLOCK_COUNT != BLOCK_COUNT ) {
            lfs2_mount(&lfs2, cfg) => LFS2_ERR_INVAL;
        }

        lfs2_t lfs22 = lfs2;
        struct lfs2_config cfg2 = *cfg;
        cfg2.block_count = AFTER_BLOCK_COUNT;
        lfs22.cfg = &cfg2;
        lfs2_mount(&lfs22, &cfg2) => 0;
        for (int i = 0; i < FILES_COUNT + 1; i++) {
            lfs2_file_t file;
            char path[1024];
            sprintf(path, "file_%03d", i);
            lfs2_file_open(&lfs22, &file, path,
                    LFS2_O_RDONLY ) => 0;
            lfs2_size_t size = BLOCK_SIZE - 0x40;
            char wbuffer[size];
            char wbuffer_ref[size];
            // Ensure one block is taken per file, but that files are not inlined.
            memset(wbuffer_ref, 'b', size);
            sprintf(wbuffer_ref, "Hi %03d", i);
            lfs2_file_read(&lfs22, &file, wbuffer, BLOCK_SIZE) => size;
            lfs2_file_close(&lfs22, &file) => 0;
            for (lfs2_size_t j = 0; j < size; j++) {
                wbuffer[j] => wbuffer_ref[j];
            }
        }
        lfs2_unmount(&lfs22);
    }
#endif
'''
